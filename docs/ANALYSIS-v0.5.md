# Анализ для GigaBot v0.5: файлы из Telegram и RAG

Документ подготовлен по результатам просмотра:
- `gigabot/docs/PLAN-v0.5.md`
- `giga_agent-main/` (RAG, загрузка файлов, типы)
- `Документация gigachat.ini` (хранилище файлов, chat/completions, эмбеддинги)
- Код gigabot: `telegram.py`, `filesystem.py`, `rag.py`, `context.py`, `loop.py`, `message.py`

---

## 1. Что уже есть и что нужно для v0.5

### 1.1 Получение файлов из Telegram

**Уже реализовано в `gigabot/channels/telegram.py`:**

- Обрабатываются: `PHOTO`, `VOICE`, `AUDIO`, `Document.ALL`.
- Файл скачивается через `bot.get_file(file_id)` → `download_to_drive()` в каталог `~/.gigabot/media/`.
- Имена документов сохраняются (с очисткой от префикса file_id), для остальных типов — расширение по MIME/типу.
- В контент сообщения добавляется ссылка на локальный путь:
  - `[image: путь]` / `[voice: путь]` / `[file: путь]` (в коде — `[media_type: file_path]`).
- Голосовые сообщения дополнительно транскрибируются через SaluteSpeech, в контент подставляется `[transcription: ...]`.

**Итог:** механика «получить файл из Telegram и отдать агенту путь» уже есть. Для v0.5 важно не ломать этот путь и убедиться, что дальше по цепочке (project move_file, knowledge index_file, отправка обратно) пути из `media` и `[file: ...]` используются единообразно.

**Из документации GigaChat (если позже понадобится «отдавать» файл в API как контекст):**

- Хранилище файлов: `POST /files` (multipart, обязательно `purpose="general"`).
- Форматы: txt, doc, docx, pdf, epub, ppt, pptx; jpeg, png, tiff, bmp; аудио (mp3, wav, ogg, opus и др.).
- Лимиты: текст до 40 МБ, изображение до 15 МБ, аудио до 35 МБ; суммарно изображения+аудио < 80 МБ.
- В запросе генерации файлы передаются в `attachments` массивом идентификаторов; для доступа нужен тот же `X-Client-ID`, что и при загрузке.

Сейчас gigabot передаёт файлы модели через текст (`[file: путь]`) и локальное чтение (file read / pdfplumber и т.д.), без загрузки в хранилище GigaChat. Для v0.5 этого достаточно; при необходимости «визуального» контекста по изображениям можно позже добавить загрузку в хранилище и `attachments`.

---

### 1.2 RAG (база знаний)

**Текущая реализация в `gigabot/agent/tools/rag.py`:**

- ChromaDB (PersistentClient), эмбеддинги через `provider.get_embeddings()` (модель из `RAGConfig.embed_model`).
- Действия: `create_project`, `delete_project`, `list_projects`, `index_file`, `index_folder`, `search`.
- Поддерживаемые форматы: `.txt`, `.pdf`, `.docx`, `.doc`, `.xlsx`, `.xls` (чтение через `_smart_read` из filesystem).
- Чтение пути: `Path(file_path).expanduser().resolve()` — без привязки к workspace; абсолютные пути (например `~/.gigabot/media/...`) подходят.

**Связь с файлами из Telegram:**

- В `loop.py` уже есть автоподстановка `file_path` из `[file: ...]` для действий `move_file` и `index_file` (`_patch_file_path`).
- Пользователь может: отправить PDF в Telegram → написать «добавь в базу знаний X» → модель вызывает `knowledge(action='index_file', project='X', file_path=...)`; путь может быть заполнен из последнего вложения.

**Что проверить/улучшить для v0.5 (по плану):**

1. Прогон сценария: отправить PDF в Telegram → «Добавь в базу знаний test» → убедиться, что вызывается `knowledge(index_file, project='test', file_path=<путь из media>)` и индексация проходит.
2. Сценарий: «Найди в базе test информацию о …» → `knowledge(search, project='test', query='...')` возвращает релевантные фрагменты.
3. При необходимости — ограничить пути RAG рабочим каталогом (workspace/allowed_dir), чтобы индексировать только разрешённые файлы (сейчас разрешены любые пути по файловой системе).

**Полезное из документации GigaChat:**

- В доке описан пример с LangChain: `langchain-gigachat`, `langchain-chroma`, `GigaChatEmbeddings`, `Chroma.from_documents`. У нас свой контур (Chroma + провайдер gigabot), но при смене эмбеддингов или хранилища этот фрагмент может пригодиться.
- Рекомендация для EmbeddingsGigaR: к запросу перед эмбеддингом добавлять инструкцию на естественном языке; к эмбеддингам документов при индексации — не добавлять.

---

### 1.3 Отправка файлов из проекта (P0 в плане)

**Проблема (из PLAN-v0.5):** по запросу «Пришли файлы из Тест/Сметы» модель вызывает `file(read)` вместо отправки файла пользователю через `message(media=[...])`.

**Что уже есть:**

- `project`: create, list, add_folder, delete_folder, **move_file** (перемещение файла в проект).
- `message`: отправка текста и вложений по путям `media=[...]`; пути резолвятся через `_resolve_path(..., workspace, None)`.

**Чего не хватает:**

1. **Новый action в project:** `send_files` — по имени проекта и опционально подпапке собрать файлы и отправить их пользователю (по сути, вызвать отправку через message или вернуть список путей и подсказать модели вызвать message).
2. **Промпт:** явно разделить сценарии «прочитай файл» и «пришли/отправь файл»: при «пришли/отправь» не вызывать `file(read)`, а использовать отправку (message с media или project(send_files)).

**Рекомендации по реализации:**

- В `ProjectTool`: добавить `action="send_files"` (параметры: `name`, `folder_name` опционально). Внутри — собрать список файлов из `projects_dir / name` (и при наличии `folder_name` — из подпапки), проверить разрешения (allowed_dir/workspace), вернуть список путей и явную инструкцию: «Чтобы отправить пользователю, вызови message(media=[...]) с этими путями» — либо сам tool может дернуть callback отправки (тогда нужна передача message_tool или send_callback в ProjectTool).
- В `context.py`: в системном промпте добавить правило вида: «Когда пользователь просит ПРИСЛАТЬ/ОТПРАВИТЬ файл из проекта — не читай файл через file(read); используй project(action="send_files", ...) или message(media=[путь_к_файлу]).»

---

### 1.4 file(write) без content (P1)

**Проблема:** «Создай файл и отправь» без указания содержимого → модель вызывает `file(write, path="...")` без `content` → после нескольких повторов срабатывает anti-loop.

**Текущее поведение:** в `FileTool._write` уже есть проверка: если `content` пустой, возвращается ошибка с просьбой указать content. По плану предлагается усилить формулировку, чтобы модель обязательно спросила у пользователя: «Что записать в файл?».

**Рекомендация:** в `filesystem.py` в ответе при отсутствии `content` явно написать что-то вроде: «СТОП: content не указан. Ты ДОЛЖЕН спросить у пользователя, что записать в файл. Ответь текстом с вопросом.» — и при необходимости в `context.py` в ПРАВИЛЕ 1 повторить, что при запросе «создай файл и отправь» без содержания нужно сначала спросить текст.

---

### 1.5 Остальное по плану

- **readability-lxml (P2):** диагностика на сервере (`python -c "from readability import Document; print('OK')"`); при необходимости переустановка/окружение — без изменений кода gigabot.
- **Деплой:** по плану — `git pull`, `pip install -e .`, `systemctl restart gigabot`, просмотр логов.

---

## 2. Что из документации и giga_agent может пригодиться

### 2.1 Документация GigaChat

- **Хранилище файлов:** если позже понадобится передавать в чат большие PDF/картинки «как есть» (без локального парсинга), сценарий: загрузка через `POST /files` с `purpose="general"`, затем передача id в `attachments` в `chat/completions`; один текст. документ в запросе — один идентификатор; для изображений/аудио — лимиты 80 МБ.
- **Токены:** в токены входят в т.ч. описания функций и история; при росте числа tools или длинных промптах стоит учитывать лимиты контекста модели.
- **Эмбеддинги и RAG:** пример с Chroma + GigaChatEmbeddings; рекомендация по инструкции к запросу для EmbeddingsGigaR — при смене модели эмбеддингов можно учесть.

### 2.2 giga_agent-main

- **RAG:** там RAG вынесен во внешний LangConnect API (`get_documents(collection_uuid, query, limit)`). У нас локальный Chroma — архитектура другая, но описание стратегий (простые запросы, глубокий анализ, цитирование) из `RAG_PROMPT` можно частично перенести в системный промпт gigabot для инструмента knowledge.
- **Файлы:** `REPLUploader`, `RunUploadFile` — загрузка файлов в runs/агентов; типы image, plotly_graph, html, text, audio. В gigabot загрузка в Telegram уже есть; при появлении «агентских» сценариев с загрузкой куда-то ещё можно взять идеи формата (filename + content + type).
- **Типы:** `FileContent`, `UploadedFile` — если в gigabot появятся структурированные объекты «файл от пользователя» (не только путь), полезно иметь единый тип (имя, путь, MIME, размер).

---

## 3. Краткий чек-лист по v0.5

| Задача | Где | Статус / действие |
|--------|-----|--------------------|
| Получение файлов из Telegram | `telegram.py` | Уже есть; проверить сценарии с project/knowledge |
| RAG: index + search | `rag.py`, `loop.py` | Реализовано; прогнать тесты 4–5 из плана |
| project(send_files) | `filesystem.py` | Добавить action, собрать файлы и либо вернуть пути + подсказку message(media=...), либо интегрировать отправку |
| Промпт «отправь файл» ≠ «прочитай» | `context.py` | Добавить явное правило и при необходимости пример |
| file(write) без content | `filesystem.py` (и при необходимости `context.py`) | Уже ошибка; усилить текст и при необходимости промпт |
| readability-lxml | Сервер | Диагностика/установка вне кода |

---

## 4. Итог

- **Файлы из Telegram:** уже получаются и передаются агенту путём; для v0.5 важно не ломать пути и согласовать их с project/knowledge/message.
- **RAG:** цепочка «файл в Telegram → index_file → search» уже поддерживается автоподстановкой `file_path`; нужно прогонять тесты и при желании ограничить пути RAG workspace’ом.
- **Критично для v0.5:** ввести `project(send_files)` и чёткое правило в промпте «пришли/отправь файл» → message(media=...) или send_files, без file(read).
- Документация GigaChat и фрагменты giga_agent полезны для расширения (хранилище API, эмбеддинги, стратегии RAG, типы файлов) при следующих итерациях.
