# Куда уходят токены GigaChat при каждом запросе

При каждом сообщении в Telegram (например, «Привет») в API GigaChat уходит **один большой запрос**: системный промпт + история + твоё сообщение + **описания всех инструментов (tools)**. Твоё «Привет» — это лишь несколько токенов; основная часть — контекст и схемы инструментов.

Ниже — примерное распределение **~5 868 токенов** на один запрос «Привет» (первое сообщение в сессии, без истории).

---

## Схема: из чего складывается запрос

```
┌─────────────────────────────────────────────────────────────────────────┐
│  Один вызов chat() при сообщении "Привет"                                │
│  Общее количество токенов: ~5 868                                       │
└─────────────────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────────────┐
  │ 1. СИСТЕМНЫЙ ПРОМПТ (system message)                    ~1 400 токенов │
  ├──────────────────────────────────────────────────────────────────────┤
  │ • Identity: кто такой GigaBot, время, среда, рабочее пространство      │
  │ • Правила для [file:], инструменты (краткий список), 8 правил вызова  │
  │ • Блоки: bootstrap (AGENTS.md, SOUL.md, USER.md, TOOLS.md, IDENTITY.md)│
  │ • Память: MEMORY.md                                                   │
  │ • Навыки: список + always_skills                                      │
  │ • Текущая сессия: канал, chat_id                                      │
  └──────────────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────────────┐
  │ 2. ОПИСАНИЯ ИНСТРУМЕНТОВ (functions)                    ~4 200 токенов │
  ├──────────────────────────────────────────────────────────────────────┤
  │ Для КАЖДОГО запроса в API передаются все tools в виде JSON Schema:    │
  │ • file       — action, path, content, destination, ...                │
  │ • project    — action, name, folder_name, file_path, ...              │
  │ • web        — action, query, url                                     │
  │ • exec       — command                                                │
  │ • message    — content, media                                        │
  │ • cron       — action, schedule, message, ...                         │
  │ • knowledge  — action, project, query, file_path, folder_path, top_k  │
  │ • tasks      — action, title, due_date, ...                           │
  │ • ocr        — image_path                                             │
  │ • generate_image — prompt                                             │
  │ • voice_note — text, ...                                             │
  │ • spawn      — task                                                   │
  │ Итого ~12 инструментов × ~300–400 токенов на схему ≈ 3 600–4 800      │
  └──────────────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────────────┐
  │ 3. ИСТОРИЯ ДИАЛОГА (history)                            ~0 токенов    │
  ├──────────────────────────────────────────────────────────────────────┤
  │ memory_window = 50 сообщений. Для первого "Привет" история пустая.    │
  │ При длинном диалоге сюда входят все роли: user / assistant / tool.   │
  └──────────────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────────────┐
  │ 4. ТЕКУЩЕЕ СООБЩЕНИЕ ПОЛЬЗОВАТЕЛЯ (user message)        ~10 токенов   │
  ├──────────────────────────────────────────────────────────────────────┤
  │ "Привет" + служебные символы/форматирование.                          │
  │ Если были вложения — добавляются [file: путь], [image: путь] и т.д.   │
  └──────────────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────────────┐
  │ 5. Накладные расходы API (роли, разметка сообщений)      ~260 токенов  │
  └──────────────────────────────────────────────────────────────────────┘
```

---

## Итоговая разбивка (приблизительно)

| Часть запроса              | Токенов (примерно) | %     |
|---------------------------|--------------------|-------|
| Системный промпт          | ~1 400             | ~24 % |
| Описания инструментов     | ~4 200             | ~72 % |
| История                   | 0                  | 0 %   |
| Сообщение «Привет»        | ~10                | ~0.2 %|
| Накладные расходы         | ~260               | ~4 %  |
| **Всего**                 | **~5 868**         | 100 % |

Поэтому даже на одно слово «Привет» списывается почти 6k токенов: модель каждый раз получает полный системный промпт и полный список инструментов (file, project, web, knowledge и т.д.). Твоё сообщение само по себе почти не влияет на счёт.

---

## Откуда берутся числа

- **Системный промпт**: `context.py` — `_get_identity()` (~2 500 символов) + при наличии bootstrap-файлы и MEMORY.md. Оценка по символам: ~4 000–5 000 символов → порядка 1 000–1 500 токенов (для русского/смешанного текста обычно ~2.5–3 символа на токен).
- **Tools**: в API уходят все инструменты из `ToolRegistry.get_definitions()` — каждый tool в формате OpenAI (name, description, parameters с полной JSON Schema). В коде это `agent/tools/*.py` (file, project, rag, web, exec, message, cron, tasks, ocr, kandinsky, salute_speech, spawn). Один инструмент с enum’ами и описаниями полей — примерно 250–450 токенов; 12 инструментов дают порядка 3 500–5 000 токенов.
- **История**: `session.get_history(max_messages=memory_window)` с `memory_window=50`. Для первого «Привет» список пустой.
- **User message**: «Привет» — 1–2 слова, плюс обёртка сообщения — порядка 5–15 токенов.

---

## Что можно сделать, чтобы снизить расход

1. **Уменьшить системный промпт** — сократить правила, не подгружать все bootstrap-файлы или подгружать только нужные по контексту.
2. **Не передавать все tools в каждый запрос** — выбирать подмножество инструментов по типу запроса (см. сценарии ниже).
3. **Уменьшить `memory_window`** — реже отправлять длинную историю (но тогда модель хуже помнит контекст диалога).
4. **Сократить JSON Schema инструментов** — короче описания и меньше полей в `parameters` там, где это возможно.

Сейчас архитектура «один большой запрос с полным контекстом и всеми tools» — поэтому ~5 868 токенов на «Привет» ожидаемы.

---

## Сценарии: как не передавать все tools

Идея: перед вызовом `provider.chat(messages, tools=...)` решать, какое подмножество `tools` отправить. Ниже — варианты от простых к более сложным.

### Сценарий 1. Роутер по ключевым словам (эвристика)

**Логика:** по тексту последнего сообщения пользователя и/или по наличию вложений (`[file:]`, `[image:]`) выбираем одну или несколько групп инструментов.

| Условие в сообщении / контексте | Какие tools передавать |
|---------------------------------|-------------------------|
| Только приветствие, вопрос «как дела», короткий текст без глаголов действия | **message** (чтобы ответить). Остальные не передаём. |
| «пришли», «отправь», «скинь» + «файл»/«из проекта»/имя проекта | **project**, **message** |
| «создай», «запиши», «положи в», «перемести в проект» + путь/файл | **file**, **project**, **message** |
| «найди в базе», «добавь в базу знаний», «индекс» | **knowledge**, **message** |
| URL в тексте или «открой сайт», «что на странице» | **web**, **message** |
| «напомни», «напомни через», «cron» | **cron**, **message** |
| «выполни команду», «запусти», «df», «ls» | **exec**, **message** |
| «нарисуй», «сгенерируй картинку» | **generate_image**, **message** |
| «озвучь», «голосовое» | **voice_note**, **message** |
| Есть `[image: ...]` и просьба про текст с фото | **ocr**, **message** |
| Ничего не подошло / длинное сложное сообщение | **все tools** (как сейчас) |

**Где менять:** в `loop.py` перед первым вызовом `provider.chat()`: по `initial_messages` (последнее user message) и `_extract_file_refs()` вызывать функцию вида `select_tools_for_request(message_text, has_file_refs, has_image_refs) -> list[str]`, затем `registry.get_definitions()` фильтровать по этому списку имён.

**Плюсы:** мало изменений, нет дополнительных вызовов API, сразу экономим токены на «Привет» и похожих репликах.  
**Минусы:** возможны ошибки классификации (пользователь написал «привет, пришли потом смету» — нужны и project, и message; или «напомни привет» — cron). Можно смягчить: при сомнении отдавать более широкий набор или все tools.

---

### Сценарий 2. Группы (профили) инструментов

**Логика:** заранее завести 3–4 набора tools и выбирать один набор на запрос.

Примеры групп:

- **minimal** — только `message` (ответ текстом/медиа). Для приветствий, вопросов без действий.
- **files** — `file`, `project`, `message`. Для работы с файлами и проектами.
- **search** — `web`, `knowledge`, `message`. Для поиска в интернете и в базе знаний.
- **full** — все инструменты (текущее поведение).

Правило выбора: эвристика по тексту (как в сценарии 1) или по первому сообщению в цепочке. Например: если длина сообщения &lt; 30 символов и нет слов из списка «файл, проект, база, найди, напомни, выполни, нарисуй, озвучь, URL» → **minimal**, иначе по ключевым словам → **files** / **search**, при остальных сомнениях → **full**.

**Где менять:** в конфиге или в коде задать группы имён tools; в `loop.py` перед `provider.chat()` вызывать `get_tool_group(message_text, refs) -> list[str]` и подставлять в API только выбранную группу.

**Плюсы:** предсказуемый размер запроса для «лёгких» сообщений.  
**Минусы:** граница между группами всё равно эвристическая; комбинированные запросы («пришли файл и найди в базе») требуют либо **full**, либо объединения групп.

---

### Сценарий 3. Два шага: сначала «намерение», потом tools

**Логика:** первый вызов к модели **без tools** — только системный промпт (сжатый) + сообщение пользователя. Модель возвращает структурированный ответ: «категория намерения» (например: greeting | send_file | search_web | search_knowledge | exec | reminder | image | other). По этой категории выбираем набор tools; второй вызов — уже с полной историей (или только user + ответ «намерения») и выбранными tools.

**Где менять:** в `loop.py`: перед основным циклом один раз вызвать провайдер с коротким system + user, распарсить ответ (JSON), по полю категории вызвать `select_tools_by_intent(intent) -> list[str]`, затем запустить текущий цикл с `messages` и отфильтрованным списком tools.

**Плюсы:** решение «какие tools нужны» принимает модель, а не ключевые слова.  
**Минусы:** два запроса вместо одного — расход токенов на первый вызов и задержка; нужен стабильный парсинг категории и fallback на «все tools», если ответ некорректен.

---

### Сценарий 4. Минимальный набор по умолчанию + расширение по требованию

**Логика:** по умолчанию в каждый запрос передаём только **message** (и, при необходимости, один–два самых частых инструмента). Если модель в ответе «просит» вызвать инструмент, которого нет в переданном списке (например, в ответе явно указано «нужен tool X» или при парсинге tool_calls приходит имя из полного реестра, но не из переданного подмножества), то повторяем запрос уже с расширенным набором (добавили нужный tool или перешли на **full**).

**Где менять:** в `loop.py` при обработке ответа модели: если `response.tool_calls` содержит имя tool, которого не было в переданном в этот вызов списке, не выполнять вызов, а пересобрать запрос с расширенным набором tools и вызвать `provider.chat()` снова (один раз).

**Плюсы:** для «Привет» почти всегда хватает одного tool (**message**), экономия максимальна.  
**Минусы:** при первом «сложном» запросе возможен лишний запрос (сначала без tool, потом с tool); логика усложняется (повтор, таймауты, ограничение на одну «добавку» за шаг).

---

### Сценарий 5. Конфигурируемые профили по каналу/чату

**Логика:** для разных каналов или chat_id заданы разные наборы tools. Например: в личке с ботом — full; в группе «только уведомления» — **message**, **cron**; в чате «документы» — **file**, **project**, **knowledge**, **message**.

**Где менять:** конфиг (по channel/chat_id или по тегу) → список имён tools или имя профиля из сценария 2; в `loop.py` при сборке запроса брать этот список и фильтровать `get_definitions()`.

**Плюсы:** можно жёстко ограничить возможности бота в определённых чатах и заодно снизить токены.  
**Минусы:** не решает задачу «в одном и том же чате иногда только привет, иногда сложный запрос» — тогда нужно комбинировать с сценарием 1 или 2.

---

### Сводка

| Сценарий | Сложность | Экономия на «Привет» | Риск ошибиться с набором tools |
|----------|-----------|------------------------|---------------------------------|
| 1. Роутер по ключевым словам | Низкая | Высокая (оставляем 1 tool) | Средний |
| 2. Группы (minimal/files/search/full) | Низкая | Высокая для minimal | Средний |
| 3. Два шага (намерение → tools) | Высокая | Зависит от первого шага | Низкий, но +1 запрос |
| 4. Минимальный набор + расширение | Средняя | Очень высокая | Низкий при повторном вызове |
| 5. Профили по каналу/чату | Низкая | Зависит от профиля | Нет (явная настройка) |

Практичный старт: реализовать **сценарий 1** или **2** в `loop.py` (выбор подмножества по тексту/вложениям), оставив возможность при несовпадении или длинном сообщении отдавать все tools.
